In Section~\ref{ssec:esm_ties} we define the structure of the ESMACS and TIES
protocols. Here we provide skeletons of the TIES protocol implemented in
HTBAC\@. In Listing~\ref{lst:ties.py} we show a customization of a production
MD simulation step.

\lstinputlisting[language=Python, label={lst:ties.py}, caption={Instance of the TIES protocol implemented with HTBAC. We import the predefined protocol `TIES' and customize its simulation steps. We assign the physical system to the protocol instance and, using the Simulation construct, we specify the conditions for all ensemble members and their type of a production MD step \texttt{step0}. We pass the protocol instance and resource request along with allocation time (walltime) to to the Runner component.}]{ties.py}

In Section~\ref{ssec:adaptive_execution} we show HTBAC's adaptive execution
capabilities. In Listing~\ref{lst:ties_adaptivity.py} we provide an
intra-protocol adaptive implementation of TIES, based on the use-case
of Section~\ref{ssec:adapt_ties}.

\lstinputlisting[language=Python, label={lst:ties_adaptivity.py}, caption={Adaptive implementation of the TIES protocol in HTBAC. Expanding on Listing~\ref{lst:ties.py}, we partition a production MD simulation step into multiple simulation steps and divide the simulation duration. Flags are passed to the Runner to save the output of the latest simulations. Between steps, an analysis script operates on partial simulation results, generating new simulation conditions for the next simulation step. The simulations from the previous step are automatically merged with the new simulations. In this implementation, we use the adaptive quadrature function which determines whether to spawn additional $\lambda$ windows.}]{ties_adaptivity.py}

% \jhanote{As written, this sub-section has nothing about HTBAC and would be
% better placed/merged in Science Driver.  What would be useful is
% pseudo-code or code listing to show how ESMACS and TIES are encoded in
% HTBAC}\jdnote{added context}

% While ESMACS and TIES protocols compute binding affinity calculations for
% different systems and purposes, their implementation in HTBAC have the same
% underlying pattern, consisting of simulations steps, followed by one or
% more analysis step(s). Designers of free energy protocols can utilize the
% simulation and analysis components of HTBAC to create any customized
% sequence of simulation(s) and/or analysis steps. The main implementation
% differences between protocols is in their design of ensemble members.

% Listing~\ref{lst:esmacs.py} shows the skeleton of the ESMACS protocol
% implemented in HTBAC. Specifically, the listing shows the customization of
% simulation conditions for a minimization step of the protocol.

% In Section~\ref{ssec:adaptive_execution} we show HTBAC's adaptive execution
% capabilities. Here we show an example of a 5 step simulation run. For
% brevity, we did not specify the simulation conditions for
% \texttt{TIES.step0--2}, which are typically minimization and equilibration
% steps. We focus on implementing adaptivity within the protocol for the
% production MD step. In a non-adaptive protocol, the production MD step
% executes for the entire simulation duration as specified by the user. The
% adaptive protocol breaks down the production MD step into multiple, shorter
% steps. Between steps, the user assigns analysis scripts that generate
% simulation conditions necessary for further simulations. The shorter
% \texttt{TIES.step3} and \texttt{TIES.step4} specify production MD phase 1
% and phase 2, respectively. Simulations from \texttt{TIES.step3} execute but
% the application does not terminate, as specified by the flag
% \texttt{terminate = false}. The adaptive quadratures function computes
% where to place subsequent $\lambda$ windows and provides the information to
% \texttt{TIES.step4}.

% The additional windows
